#include <stdio.h>
#include <fcntl.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

#define FILENAME "tree.ppm"
#define AUTHOR "Dennis Yatunin"

// XMAX, YMAX, and CMAX must all be positive integers
#define XMAX 5999
#define YMAX 5999
#define CMAX 255

#define PI 3.14159265

int is_colored(unsigned char arr[XMAX + 1][YMAX + 1][3], int x, int y) {
	return arr[x][y][0] + arr[x][y][1] + arr[x][y][2];
}

void draw_bark(unsigned char arr[XMAX + 1][YMAX + 1][3], int x, int y) {
	arr[x][y][0] = 83 * CMAX / 255;
	arr[x][y][1] = 49 * CMAX / 255;
	arr[x][y][2] = 24 * CMAX / 255;
}

void draw_leaf(unsigned char arr[XMAX + 1][YMAX + 1][3], int x, int y) {
	arr[x][y][0] = 30 * CMAX / 255;
	arr[x][y][1] = 147 * CMAX / 255;
	arr[x][y][2] = 45 * CMAX / 255;
}

void draw_sky(unsigned char arr[XMAX + 1][YMAX + 1][3], int x, int y) {
	double radius = sqrt(
		(x - XMAX / 2) * (x - XMAX / 2) / ((XMAX / 30) * (XMAX / 30)) +
		y * y / ((YMAX / 30) * (YMAX / 30))
		);
	int offset = (int) (CMAX / 30 * radius / (radius + 10) * sin(radius));
	arr[x][y][0] = (135 + offset) * CMAX / 255;
	arr[x][y][1] = (206 + offset) * CMAX / 255;
	arr[x][y][2] = (240 + offset) * CMAX / 255;
}

void create_image(unsigned char arr[XMAX + 1][YMAX + 1][3]) {
	int x, y, bark_pixels_left, iteration, r;
	double tempx, tempy;
	x = XMAX / 2;
	y = YMAX;
	bark_pixels_left = 5;
	srand(time(NULL));
	// The following fractal creation algorithm is loosely based on what is
	// known as the "Chaos Algorithm," in which a point is randomly moved
	// according to one of three functions, with each move bringing the point
	// closer to the Serpinski Triangle (mathematically speaking, the set of
	// points generated by infinitely many moves is dense in the Serpinski
	// Triangle). The fractal tree that I designed also uses three functions -
	// one of which (when applied to the set of all points of the tree) shrinks
	// the tree by a factor of 1/2 and rotates it 120 degrees clockwise, the
	// second of which shrinks it by a factor of 1/2 and rotates it 120 degrees
	// counterclockwise, and the third of which shrinks it by a factor of 3/4
	// and translates it 1/4 units upward. I also added a fourth function,
	// which occurs approximately 1 in every 20 iterations and gives an air
	// of "fuzziness" to the tree. It takes the point and moves it randomly
	// toward the center of the tree (where the stem should be), which prevents
	// the set of points generated by the algorithm from becoming truly dense
	// in the fractal.
	for (iteration = 0; iteration < 10000000; iteration++) {
		r = rand() % 20;
		if (r < 8) {
			// dilate by 1/2 around (XMAX / 2, 0) and translate
			// up by YMAX / 4
			x = (2 * x + XMAX) / 4;
			y = y / 2 + YMAX / 4;
			if (r < 4) {
				// rotate clockwise by 2/3*PI radians around
				// (XMAX / 2, 3 * YMAX / 4)
				tempx =
					cos(2 * PI / 3) * (x - XMAX / 2) -
					sin(2 * PI / 3) * (y - 3 * YMAX / 4) +
					XMAX / 2;
				tempy =
					sin(2 * PI / 3) * (x - XMAX / 2) +
					cos(2 * PI / 3) * (y - 3 * YMAX / 4) +
					3 * YMAX / 4;
			}
			else {
				// rotate counterclockwise by 2/3*PI radians around
				// (XMAX / 2, 3 * YMAX / 4)
				tempx =
					cos(-2 * PI / 3) * (x - XMAX / 2) -
					sin(-2 * PI / 3) * (y - 3 * YMAX / 4) +
					XMAX / 2;
				tempy =
					sin(-2 * PI / 3) * (x - XMAX / 2) +
					cos(-2 * PI / 3) * (y - 3 * YMAX / 4) +
					3 * YMAX / 4;
			}
			x = (int) tempx;
			y = (int) tempy;
		}
		else if (r < 19) {
			// dilate by 3/4 around (XMAX / 2, 0)
			x = (6 * x + XMAX) / 8;
			y = 3 * y / 4;
		}
		else {
			// dilate by 1/20 around the line x = XMAX / 2 and translate
			// closer to the line by a random value
			x =
				XMAX / 2 + ((x > XMAX / 2) ? 1 : -1) *
				(
					rand() % (
						(2 * x - XMAX) / 40 +
						((x > XMAX / 2) ? 1 : -1)
						)
					);
		}
		// The first five points after a point that was moved into the center
		// of the tree are colored brown, as well as the point that was moved
		// to the center itself. All other points are colored green.
		if (r < 19) {
			if (!is_colored(arr, x, y)) {
				if (bark_pixels_left) {
					draw_bark(arr, x, y);
					bark_pixels_left--;
				}
				else {
					draw_leaf(arr, x, y);
				}
			}
		}
		else {
			bark_pixels_left = 5;
			draw_bark(arr, x, y);
		}
	}
	// The remaining points (points not in the tree) are colored blue.
	for (y = 0; y <= YMAX; y++) {
		for (x = 0; x <= XMAX; x++) {
			if (!is_colored(arr, x, y)) {
				draw_sky(arr, x, y);
			}
		}
	}
}

void create_file(unsigned char arr[XMAX + 1][YMAX + 1][3]) {
	int fd = open(FILENAME, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	// Each red, green, and blue value will take up at most
	// ((int) log10(CMAX) + 1) characters, and each will be
	// followed by a ' ' character.
	char line[XMAX * 3 * ((int) log10(CMAX) + 2)];
	int line_len;

	line_len = sprintf(
		line,
		"# %s\n# Author: %s\nP3\n%d %d\n%d\n",
		FILENAME, AUTHOR, XMAX + 1, YMAX + 1, CMAX
		);
	write(fd, line, line_len);

	int x, y;
	for (y = 0; y <= YMAX; y++) {
		line_len = 0;
		for (x = 0; x <= XMAX; x++) {
			line_len += sprintf(
				line + line_len,
				"%d %d %d ",
				arr[x][y][0], arr[x][y][1], arr[x][y][2]
				);
		}
		line_len += sprintf(line + line_len, "\n\0");
		write(fd, line, line_len);
	}
}

int main() {
	static unsigned char arr[XMAX + 1][YMAX + 1][3];
	create_image(arr);
	create_file(arr);
	return 0;
}
